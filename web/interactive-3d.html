<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hydraulic Piston HMI — 3D Visualization</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #050910;
      --accent: #1de9b6;
      --accent-2: #ffb74d;
      --text: #eaf2ff;
      --muted: #c7d0ed;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Space Grotesk', 'Segoe UI', sans-serif;
      background: radial-gradient(120% 120% at 15% 10%, rgba(29,233,182,0.18), transparent),
                  radial-gradient(120% 120% at 85% 5%, rgba(255,183,77,0.14), transparent),
                  linear-gradient(145deg, #050910 0%, #0b1730 50%, #050910 100%);
      color: var(--text);
      min-height: 100vh;
      overflow: hidden;
    }
    header {
      position: fixed;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 14px;
      background: rgba(0,0,0,0.5);
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.1);
      backdrop-filter: blur(10px);
      z-index: 10;
    }
    .chip {
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: var(--muted);
      font-size: 13px;
    }
    .panel {
      position: fixed;
      right: 16px;
      top: 70px;
      width: 280px;
      background: rgba(8,14,28,0.8);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 14px;
      backdrop-filter: blur(10px);
      z-index: 10;
      box-shadow: 0 10px 30px rgba(0,0,0,0.4);
    }
    .panel.sample {
      top: auto;
      bottom: 20px;
      width: 320px;
    }
    h3 { margin: 0 0 8px; }
    h4 { margin: 0 0 6px; }
    p { margin: 0 0 6px; color: var(--muted); }
    .btn {
      display: inline-block;
      padding: 10px 12px;
      margin: 6px 4px 0 0;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: linear-gradient(120deg, var(--accent), #5efce8);
      color: #051020;
      font-weight: 700;
      cursor: pointer;
    }
    .btn.secondary {
      background: transparent;
      color: var(--text);
    }
    canvas {
      display: block;
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
    }
    #info {
      position: fixed;
      left: 16px;
      bottom: 16px;
      padding: 12px 14px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      color: var(--muted);
      font-size: 14px;
      backdrop-filter: blur(8px);
      max-width: 340px;
      line-height: 1.5;
      z-index: 10;
    }

    @media (max-width: 780px) {
      body {
        overflow: auto;
      }
      header {
        position: relative;
        transform: none;
        margin: 10px 12px 6px;
        flex-direction: column;
        align-items: flex-start;
        z-index: 20;
      }
      header .chip { font-size: 12px; padding: 6px 10px; }
      .panel,
      .panel.sample {
        position: relative;
        width: calc(100% - 24px);
        margin: 8px 12px 0;
        z-index: 20;
        padding: 10px 12px;
        border-radius: 12px;
      }
      .panel h3,
      .panel h4 { margin-bottom: 4px; }
      .panel p { font-size: 13px; }
      .btn {
        width: 100%;
        text-align: center;
        padding: 8px 10px;
        margin-top: 6px;
        font-size: 14px;
      }
      .btn + .btn { margin-top: 4px; }
      .panel.sample {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 8px;
      }
      .panel.sample .badge { grid-column: 1 / -1; }
      .panel.sample #durationList { font-size: 12px; }
      #statusText { font-size: 14px; }
      .chip { font-size: 12px; padding: 6px 10px; }
      .panel .btn.secondary { margin-left: 0; }
      .panel > div button + button { margin-left: 0; }
      .panel > div { display: grid; gap: 6px; }
      .panel p { margin-bottom: 4px; }
      #info {
        position: relative;
        margin: 10px 12px 14px;
        max-width: none;
        z-index: 20;
        font-size: 13px;
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="chip" style="color:var(--accent);font-weight:700;">Hydraulic Piston HMI · 3D</div>
    <div class="chip">Fake EtherCAT Bus · Start / Stop / Single Cycle</div>
    <a class="btn secondary" href="index.html">Back to index</a>
  </header>
  <div class="panel">
    <h3>Presentation Controls</h3>
    <p>Shows 3 pistons, bus links, and command flow with light effects.</p>
    <div>
      <button class="btn" id="startBtn">Start (Latch)</button>
      <button class="btn secondary" id="stopBtn">Stop</button>
      <button class="btn secondary" id="singleBtn">Single Cycle</button>
    </div>
    <p style="margin-top:10px;">Orbit with right mouse/drag, zoom with wheel.</p>
  </div>
  <div class="panel sample">
    <h4>Panel Example</h4>
    <div class="badge">Status</div>
    <div id="statusText" style="color:var(--text);margin-bottom:6px;">Idle</div>
    <div class="badge">Durations (s)</div>
    <div id="durationList" style="color:var(--muted);font-family:'Fira Code',monospace;font-size:13px;"></div>
  </div>
  <div id="info">
    HMI commands (start/single/stop) travel over the bus to the client. The bus sphere is the master, piston blocks are the slave; lights show signal flow and strokes show sequence progress.
  </div>

  <script type="module">
    import * as THREE from "./vendor/three.module.js";
    import { OrbitControls } from "./vendor/OrbitControls.js";

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x040811);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(6, 5, 10);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;

    const handleResize = () => {
      const w = window.innerWidth;
      const h = window.innerHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    };
    window.addEventListener("resize", handleResize);

    const hemiLight = new THREE.HemisphereLight(0x7ef7ff, 0x0f1627, 0.6);
    scene.add(hemiLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 6);
    dirLight.castShadow = true;
    scene.add(dirLight);

    const grid = new THREE.GridHelper(20, 20, 0x1de9b6, 0x1e263b);
    grid.position.y = -1;
    scene.add(grid);

    const plane = new THREE.Mesh(
      new THREE.PlaneGeometry(30, 30),
      new THREE.MeshStandardMaterial({ color: 0x0b1327, roughness: 0.9, metalness: 0.1 })
    );
    plane.rotation.x = -Math.PI / 2;
    plane.position.y = -1.01;
    plane.receiveShadow = true;
    scene.add(plane);

    // Bus node (master)
    const busGeo = new THREE.SphereGeometry(0.6, 32, 32);
    const busMat = new THREE.MeshStandardMaterial({ color: 0x1de9b6, emissive: 0x0a2f2a, emissiveIntensity: 0.6, metalness: 0.4 });
    const bus = new THREE.Mesh(busGeo, busMat);
    bus.position.set(0, 2.5, 0);
    bus.castShadow = true;
    scene.add(bus);

    const pistons = [];
    const pistonGroup = new THREE.Group();
    scene.add(pistonGroup);

    const colors = [0x1de9b6, 0xffb74d, 0x5c6fff];
    for (let i = 0; i < 3; i++) {
      const base = new THREE.Mesh(
        new THREE.BoxGeometry(1.2, 0.4, 1.2),
        new THREE.MeshStandardMaterial({ color: 0x101a34, metalness: 0.4, roughness: 0.6 })
      );
      base.position.set((i - 1) * 3, -0.8, 0);
      base.castShadow = true;
      base.receiveShadow = true;
      pistonGroup.add(base);

      const barrel = new THREE.Mesh(
        new THREE.CylinderGeometry(0.8, 0.9, 2.2, 26),
        new THREE.MeshStandardMaterial({ color: 0x182542, metalness: 0.35, roughness: 0.55 })
      );
      barrel.position.set((i - 1) * 3, 0.35, 0);
      barrel.castShadow = true;
      barrel.receiveShadow = true;
      pistonGroup.add(barrel);

      const rod = new THREE.Mesh(
        new THREE.CylinderGeometry(0.12, 0.12, 1.8, 18),
        new THREE.MeshStandardMaterial({ color: 0xd7e3f5, metalness: 0.85, roughness: 0.25 })
      );
      rod.castShadow = true;
      rod.receiveShadow = true;

      const head = new THREE.Mesh(
        new THREE.CylinderGeometry(0.65, 0.65, 0.38, 24),
        new THREE.MeshStandardMaterial({ color: colors[i], emissive: colors[i], emissiveIntensity: 0.4, metalness: 0.7, roughness: 0.3 })
      );
      head.castShadow = true;
      head.receiveShadow = true;

      const minY = 0.6;
      const maxY = 1.8;
      head.position.set((i - 1) * 3, minY, 0);
      rod.position.set((i - 1) * 3, (minY + 0.05), 0);

      pistonGroup.add(rod);
      pistonGroup.add(head);

      pistons.push({ head, rod, base, minY, maxY });
    }

    // Connection beams master -> pistons
    const beams = pistons.map((p, idx) => {
      const geo = new THREE.CylinderGeometry(0.05, 0.05, 2.6, 16);
      const mat = new THREE.MeshStandardMaterial({ color: colors[idx], emissive: colors[idx], emissiveIntensity: 0.3 });
      const beam = new THREE.Mesh(geo, mat);
      beam.position.set((idx - 1) * 3, 1.5, 0);
      beam.rotation.z = Math.PI / 2;
      beam.castShadow = true;
      scene.add(beam);
      return beam;
    });

    const clock = new THREE.Clock();

    // Sequence + latch simulation
    const durations = [
      { extend: 1.5, retract: 1.0 },
      { extend: 2.0, retract: 1.0 },
      { extend: 2.5, retract: 1.0 },
    ];
    let stages = [];
    let running = false;
    let latched = false;
    let stageIndex = 0;
    let stageStartedAt = 0;
    let nextCycleAt = null;
    let statusText = "Idle";

    function updateRod(piston) {
      const headY = piston.head.position.y;
      const baseY = -0.4;
      const rodLength = Math.max(0.5, headY - baseY);
      piston.rod.scale.set(1, rodLength, 1);
      piston.rod.position.y = baseY + rodLength / 2;
    }

    function setHeadPosition(idx, frac, action) {
      const p = pistons[idx];
      const startY = action === "extend" ? p.minY : p.maxY;
      const endY = action === "extend" ? p.maxY : p.minY;
      const y = startY + (endY - startY) * Math.min(1, Math.max(0, frac));
      p.head.position.y = y;
      updateRod(p);
      p.head.material.emissiveIntensity = 0.35 + 0.3 * frac;
    }

    function resetPistons() {
      pistons.forEach((p) => {
        p.head.position.y = p.minY;
        updateRod(p);
        p.head.material.emissiveIntensity = 0.25;
      });
    }

    function buildStages() {
      stages = [];
      durations.forEach((d, idx) => {
        stages.push({ idx, action: "extend", duration: d.extend });
        stages.push({ idx, action: "retract", duration: d.retract });
      });
    }

    function startCycle(latchMode) {
      buildStages();
      latched = latchMode;
      running = true;
      stageIndex = 0;
      stageStartedAt = clock.getElapsedTime();
      nextCycleAt = null;
      statusText = latchMode ? "Running (latched)" : "Running (single)";
      setHeadPosition(stages[0].idx, 0, stages[0].action);
    }

    function stopCycle() {
      running = false;
      latched = false;
      stageIndex = 0;
      nextCycleAt = null;
      statusText = "Stopped";
      resetPistons();
    }

    function updateSequence() {
      const now = clock.getElapsedTime();
      if (!running) {
        if (latched && nextCycleAt && now >= nextCycleAt) {
          startCycle(true);
        }
        return;
      }
      if (stageIndex >= stages.length) {
        running = false;
        statusText = "Complete";
        if (latched) {
          nextCycleAt = now + 0.5;
          statusText = "Waiting (latched)";
        }
        return;
      }
      const stage = stages[stageIndex];
      const elapsed = now - stageStartedAt;
      const frac = Math.min(1, Math.max(0, elapsed / stage.duration));
      setHeadPosition(stage.idx, frac, stage.action);
      if (elapsed >= stage.duration) {
        stageIndex += 1;
        stageStartedAt = now;
        if (stageIndex >= stages.length) {
          running = false;
          statusText = "Complete";
          if (latched) {
            nextCycleAt = now + 0.5;
            statusText = "Waiting (latched)";
          }
        }
      }
    }

    function pulseBeams() {
      const t = clock.getElapsedTime();
      beams.forEach((b, idx) => {
        const wave = Math.sin(t * 2 + idx) * 0.5 + 0.5;
        const factor = running ? 0.35 + wave * 0.4 : 0.05;
        b.material.emissiveIntensity = factor;
        b.scale.set(1, running ? 1 + wave * 0.15 : 0.8, 1);
      });
      const wobble = Math.sin(t * 1.4) * 0.05;
      bus.scale.set(1 + wobble, 1 + wobble, 1 + wobble);
    }

    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const singleBtn = document.getElementById("singleBtn");
    const statusLabel = document.getElementById("statusText");
    const durationList = document.getElementById("durationList");

    function updateDurationList() {
      durationList.innerText = durations
        .map((d, i) => `P${i + 1}: ${d.extend}s / ${d.retract}s`)
        .join("\n");
    }
    updateDurationList();

    startBtn.addEventListener("click", () => { startCycle(true); });
    stopBtn.addEventListener("click", () => { stopCycle(); });
    singleBtn.addEventListener("click", () => { startCycle(false); });

    function render() {
      requestAnimationFrame(render);
      controls.update();
      updateSequence();
      pulseBeams();
      statusLabel.innerText = statusText;
      renderer.render(scene, camera);
    }

    render();

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener("resize", onResize);
  </script>
</body>
</html>
